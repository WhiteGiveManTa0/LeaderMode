//========= Copyright ?1996-2003, Valve LLC, All rights reserved. ============
//
// The copyright to the contents herein is the property of Valve, L.L.C.
// The contents may be used and/or copied only with the written permission of
// Valve, L.L.C., or in accordance with the terms and conditions stipulated in
// the agreement/contract under which the contents have been supplied.
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef KEYVALUES_H
#define KEYVALUES_H

#ifdef _WIN32
#pragma once
#endif

// #include <vgui/VGUI.h>

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif

#include "utlvector.h"

class IFileSystem;
#define IBaseFileSystem IFileSystem
class CUtlBuffer;
class Color;
typedef FILE *FileHandle_t;

//-----------------------------------------------------------------------------
// Purpose: Simple recursive data access class
//			Used in vgui for message parameters and resource files
//			Destructor deletes all child KeyValues nodes
//			Data is stored in key (string names) - (string/int/float)value pairs called nodes.
//
//	About KeyValues Text File Format:

//	It has 3 control characters '{', '}' and '"'. Names and values may be quoted or
//	not. The quote '"' charater must not be used within name or values, only for
//	quoting whole tokens. You may use escape sequences wile parsing and add within a
//	quoted token a \" to add quotes within your name or token. When using Escape
//	Sequence the parser must now that by setting KeyValues::UsesEscapeSequences( true ),
//	which it's off by default. Non-quoted tokens ends with a whitespace, '{', '}' and '"'.
//	So you may use '{' and '}' within quoted tokens, but not for non-quoted tokens.
//  An open bracket '{' after a key name indicates a list of subkeys which is finished
//  with a closing bracket '}'. Subkeys use the same definitions recursively.
//  Whitespaces are space, return, newline and tabulator. Allowed Escape sequences
//	are \n, \t, \\, \n and \". The number character '#' is used for macro purposes 
//	(eg #include), don't use it as first charater in key names.
//-----------------------------------------------------------------------------
class KeyValues
{
public:
	KeyValues( const char *setName );

	// Quick setup constructors
	KeyValues( const char *setName, const char *firstKey, const char *firstValue );
	KeyValues( const char *setName, const char *firstKey, const wchar_t *firstValue );
	KeyValues( const char *setName, const char *firstKey, int firstValue );
	KeyValues( const char *setName, const char *firstKey, const char *firstValue, const char *secondKey, const char *secondValue );
	KeyValues( const char *setName, const char *firstKey, int firstValue, const char *secondKey, int secondValue );

	// Section name
	virtual const char *GetName() const;
	void SetName( const char *setName);

	// gets the name as a unique int
	virtual int GetNameSymbol() const;

	// File access. Set UsesEscapeSequences true, if resource file/buffer uses Escape Sequences (eg \n, \t)
	virtual bool LoadFromFile( IBaseFileSystem *filesystem, const char *resourceName, const char *pathID = NULL );
	virtual bool SaveToFile( IBaseFileSystem *filesystem, const char *resourceName, const char *pathID = NULL);

	// Read from a buffer...  Note that the buffer must be null terminated
	bool LoadFromBuffer( const char *buffer );

	// Find a keyValue, create it if it is not found.
	// Set bCreate to true to create the key if it doesn't already exist (which ensures a valid pointer will be returned)
	virtual KeyValues *FindKey(const char *keyName, bool bCreate = false);
	virtual KeyValues *FindKey(int keySymbol) const;
	virtual KeyValues *CreateNewKey();		// creates a new key, with an autogenerated name.  name is guaranteed to be an integer, of value 1 higher than the highest other integer key name
	virtual void	   RemoveSubKey(KeyValues *subKey);	// removes a subkey from the list, DOES NOT DELETE IT

	// Key iteration
	virtual KeyValues *GetFirstSubKey();	// returns the first subkey in the list
	virtual KeyValues *GetNextKey();		// returns the next subkey
	void AddSubKey( KeyValues *pSubkey );
	void SetNextKey( KeyValues * pDat);

	// Data access
	virtual int   GetInt( const char *keyName = NULL, int defaultValue = 0 );
	virtual float GetFloat( const char *keyName = NULL, float defaultValue = 0.0f );
	virtual const char *GetString( const char *keyName = NULL, const char *defaultValue = "" );
	virtual const wchar_t *GetWString( const char *keyName = NULL, const wchar_t *defaultValue = L"" );
	virtual void *GetPtr( const char *keyName = NULL, void *defaultValue = (void*)0 );
	Color GetColor( const char *keyName = NULL /* default value is all black */);
	int GetUint64( const char *keyName = NULL, uint64 defaultValue = 0 );
	virtual bool  IsEmpty(const char *keyName = NULL);

	// Key writing
	virtual void SetWString( const char *keyName, const wchar_t *value );
	virtual void SetString( const char *keyName, const char *value );
	virtual void SetInt( const char *keyName, int value );
	virtual void SetFloat( const char *keyName, float value );
	virtual void SetPtr( const char *keyName, void *value );
	void SetColor( const char *keyName, Color value);
	void SetUint64( const char *keyName, uint64 value );

	// Memory allocation (optimized)
	void *operator new( size_t iAllocSize );
	void *operator new( size_t iAllocSize, int nBlockUse, const char *pFileName, int nLine );
	void operator delete( void *pMem );

	// Allocate & create a new copy of the keys
	virtual KeyValues *MakeCopy( void ) const;

	// Clear out all subkeys, and the current value
	virtual void Clear( void );

	// Data type
	enum types_t
	{
		TYPE_NONE,
		TYPE_STRING,
		TYPE_INT,
		TYPE_FLOAT,
		TYPE_PTR,
		TYPE_WSTRING,
		TYPE_COLOR,
		TYPE_UINT64,
	};
	virtual types_t GetDataType(const char *keyName = NULL);

	// Virtual deletion function - ensures that KeyValues object is deleted from correct heap
	virtual void deleteThis();

private:
	KeyValues( KeyValues& );	// prevent copy constructor being used

	// prevent delete being called except through deleteThis()
	~KeyValues();

	KeyValues* CreateKey( const char *keyName );
	
	void RecursiveSaveToFile( IBaseFileSystem *filesystem, CUtlBuffer& buffer, int indentLevel );
	void WriteConvertedString( CUtlBuffer& buffer, const char *pszString );
	
	void RecursiveLoadFromBuffer( char **buffer );

	void AllocateValueBlock( int iAllocSize );
	void FreeAllocatedValue( void );

	void Init();
	void WriteIndents( CUtlBuffer& buffer, int indentLevel );

	int m_iKeyName;	// keyname is a symbol defined in KeyValuesSystem

	// we don't delete these
	union
	{
		int m_iValue;
		float m_flValue;
		void *m_pValue;
		char *m_sValue;
		wchar_t *m_wsValue;
		unsigned char m_Color[4];
	};
	
	unsigned short m_iDataType; 
	short m_iAllocationSize;

	KeyValues *m_pPeer;	// pointer to next key in list
	KeyValues *m_pSub;	// pointer to Start of a new sub key list
};

#endif // KEYVALUES_H
